权限修饰符
-----
java子类重写继承的方法时，不可以降低方法的访问权限；
子类继承父类的访问修饰符要比父类大；
继承当中子类抛出的异常必须是父类抛出的异常的自异常，或者子类抛出的异常比父类更少。

接口和抽象类
-----
java接口和java抽象类代表的就是抽象类型，就是我们需要提出的抽象层的具体表现。

java接口和java抽象类区别：java抽象类可以提供某些方法的部分实现，java接口不可以。
                          如果向java接口里加入一个新方法，所有实现这个接口的类就无法成功通过编译了。需要让每个类都再实现这个方法才行。
                          如果向java抽象类里加入一个新的具体方法，那么它所有的子类都可以一下得到这个新方法。

                          抽象类的实现只能由这个抽象类的子类给出，实现处于抽象类所定义出的继承的等级结构中，
                          由java语言的单继承性，所以抽象类作为类型定义工具的效能大打折扣。
                          任何一个实现了java接口所规定的方法的类都可以具有这个接口的类型，而一个类可以实现任意多个java接口。
java接口
-----
java接口是一系列方法的声明，方法特征的集合，一个接口只有方法的特征没有方法的实现。
两种含义：一，java接口，java语言中存在的结构，有特定的语法和结构；java接口
          二，一个类具有的方法和特征集合，是一种逻辑上的抽象。接口

功能
    java接口的方法只能是抽象的和公开的，java接口不能有构造器，java接口可以有public，static和final属性，即接口中的
    属性可以定义为public static final int value=6；
（构造器）缺省/非缺省
    在创建对象时执行初始化，当创建一个对象时，系统会为这个对象的实例进行默认的初始化。如果想改变这种默认的初始化，就可以用自定义构造器。

java内部类外部类
-----
1、内部类可声明成public或private。当内部类声明成public或private时，对其访问的限制于成员变量和成员方法完全相同。
2、外部类声明的属性可以被内部类访问，内部类的声明无法被外部访问
3、用static可以声明内部类，用static声明的内部类则变成外部类，但是只能访问static的外部属性。
4、内部类不仅可以在类中定义，也可以在方法中定义。
5、在方法中定义的内部类只能访问方法中的final类型的局部变量，因为用final定义的局部变量相当于一个常量，
它的生命周期超出方法运行的生命周期。
局部变量：方法里定义的变量
内部类能够访问某局部变量，说明这个内部类不是在类中定义的内部类，而是在方法中定义的内部类，局部内部类。
局部变量的作用域：局部变量是在某个方法中定义，，当该方法执行完成后，局部变量消失。【局部变量分配在JVM的虚拟机栈中，这部分内存空间随着程序的执行自动回收】。
即：局部变量的作用域在“方法范围内”。
当局部内部类访问局部变量时，会扩大局部变量的作用域。开启线程后，要负责正常生命周期结束的时间上，局部变量的值不能被改变。

java不同包访问protected方法-匿名类
-----
声明一个匿名类继承该类，并定义一个方法，在这个方法内super调用想调用的方法。（也可以继承，然后调用父类的protected方法）。
new TestClass（）.test（）/test()protected方法不同包，无法调用。用匿名类
new TestClass(){
void callParentTest(){
super.test();
}
}.callParentTest();

匿名内部类
interface A{
public void fun1();
}

class B{
int i=10;
public void get(A a)
{
a.fun1();
}

public void test(){
this.get(new A(){
public void fun1(){
//method;
}
});
}

}

-----
override覆盖

覆盖了一个方法并且对其重写，以求达到不同的作用。
覆盖---对接口方法的实现。
1、覆盖方法标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果。
2、返回值一致。
3、抛出的异常小于等于原方法。
4、不能为private。

overload重载

定义一些名称相同的方法，通过定义不同的输入参数，来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。

1、在使用重载时只能通过不同的参数样式。
2、不能通过访问权限、返回类型、抛出的异常进行重载
3、方法的异常类型和数目不会对重载造成影响。
4、继承中，父类方法的访问权限是private，那么就不能在子类对其进行重载。

-----
classloader类加载器

将class文件加载到JVM虚拟机中去。是动态加载的。
class文件是字节码格式文件，虚拟机可以理解的是javac转换java文件之后出来的class文件。
-----
final 用于声明属性、方法和类，分别表示属性不可变，方法不可重写，类不可继承。
-----
GC

当程序员创建对象时，GC就开始监控这个对象的地址，大小及使用情况。

GC采用有向图的方式记录和管理堆中所有的对象。通过这种方式确定哪些对象是可达的，不可达的。
当GC确定一些对象不可达时，GC就有责任回收这些内存空间。
程序员可以手动执行System.gc()，但是语言规范不一定会保证GC运行。

System.gc()的工作原理：
java中内存分配是随着new一个新的对象来实现的。
System.gc()可以“改进”内存回收的机制的。用于提醒虚拟机：程序员希望进行一次垃圾回收。
之后就根据不同的虚拟机进行不同的策略。

没有任何可达变量指向的对象。
1 a.v = b;
2 b.v = c;
3 /*
4  *Watch out !
5  */
6 a.v = d;
看一下这段代码：
第一行：对象a的变量v指向了对象b
第二行：对象b的变量v指向了对象c
第六行：对象a的变量v指向了变量d。
这个时候，虽然变量c指向的对象有c以及b.v指向它，但是它们都已经不可达了，为什么？因为唯一可以找到它们的是a.v，但是现在a.v指向了d，所以他们就是不可达的了。
-----
静态变量属于整个类，局部变量不能用static修饰























