Volatile

一、内存模型的相v概念
----
计算机在执行程序时，每条指令都是在CPU中执行，执行过程中会涉及到数据读取和写入。
程序运行的临时数据是存放在主存(物理内存)当中的，
由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多。
如果任何时候对数据的操作都要通过和内存的交互来进行，那么就会大大降低执行的速度。

因此CPU里面就有了高速缓存。

也就是，当程序在运行过程中，会将运算需要的数据存主存复制一份到CPU高速缓存中，那么CPU进行计算时就可以直接从
它的高速缓存读取数据和向其中写入数据。当运算结束的时候，再将高速缓存中的数据刷新到主存当中。

i = i + 1;

在执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存，然后CPU执行指令对 i 加 1 操作。
运算结束后，再将高速缓存中的 i 的值刷新到主存当中。

这个代码在单线程中没有问题，多线程中就不是了。多核CPU 每个线程都可能运行于不同的CPU中，每个线程都有自己的
高速缓存（单核CPU的线程调度形式也会有问题）。

如果同时有两个线程执行这个代码，其中I都是初始值为0，两个线程执行完之后I的值会变成2？

其实不是，线程1读取i的初始值，存入自己的CPU高速缓存中，线程2也是，然后双方加1之后，各自刷新高速缓存区的值，到内存中。
这就是缓存一致性问题。通常称这种多线程变量为共享变量(多个线程都可以从主存读取调用，进行使用上传)。

如果一个变量在多个CPU中都存在缓存（多线程编程时才出现），那么就可能存在缓存不一致问题，各个线程，各有各的变量。

为了解决缓存不一致性问题，通常来说有以下两种解决方法：
1）通过在总线加LOCK#所的方式
2）通过缓存一致性协议
这两种方法都是硬件层面上提供的方式。

在早期的CPU当中，是通过在总线加锁的方式解决缓存不一致的问题。但是CPU和其他通信都是通过总线来进行的，
如果对总线加lock#的话，就会阻塞其他CPU对其他部件的访问（如内存），使得只能有一个CPU能使用这个变量的内存。
比如，如果一个线程在执行i=i+1;如果在执行这段代码的过程中，在总线上加锁，那么只能等待这段代码执行完毕后，
别的CPU才能从变量所在的内存读取变量，然后进行操作。效率低下。

缓存一致性协议：MESI。保证每个缓存区的共享变量副本是一致的。
核心思想是：当CPU写数据的时候，如果发现操作变量是共享变量，即在别的CPU也存在该变量的副本，会发出信号，
通知其他的CPU将该变量的缓存行设置为无效状态。因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的
缓存行是无效的，就会去内存中重新获取。

内存模型图

二.并发编程的三个概念
-----

并发编程的三个问题:原子性问题，可见性问题，有序性问题。

1.原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
---
1.2.例子：
如果从A账户向B账户转1000元，那么必然包括两个操作：从账户A减去1000元，往账户B加上1000元。
如果不具备原子性，有可能导致A减去1000元，而B没有加上1000元。

所以这两个操作必须同时进行，才会不出现意外。

1.3.Java中的原子性
在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，这些操作是不可被中断的，要么执行，要么不执行.
x=10  √
Y=x   ×
x++   ×
x=x+1 ×
如果要实现更大范围的操作，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻
只有一个线程执行该代码块。就不存在原子性问题，保证了原子性。

2.可见性:当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程就能够立即看到修改的值。
---
2.1实例
//线程1
int i=0;
i=10;

//线程2
j=i;

线程1执行到i=10的时候，会把i=10的值加入到自己的工作内存cache中，但是没有添加到主存。
线程2执行j=i,它会先去主存读取i的值，并加载到线程2的工作内存，但是i=0。

2.2java中的可见性

对于可见性，java提供了volatile关键字来保证可见性。
当一个共享变量被volatile修饰时，它会保证修改的值立即被更新到主存，当有其他线程需要读取时，
它会去主存中读取新值。

通过synchronized和lock也能保证可见性，synchronized和lock能保证同一时刻只有一个线程获取锁然后执行同步代码
并且在释放锁之前会将对变量的修改刷新到主存中。

3.有序性：即程序执行的顺序按照代码的先后顺序执行。

3.1实例
int i=0;
boolean flag=false;
i=1;//语句1
flag=ture;//语句2

语句1不一定会在语句2之前运行，因为有指令重排序(Instruction Recorder)
一般来说，处理器为了提高效率会进行优化，是在保证最终程序执行结果和顺序执行结果一致的
情况下进行。
再例如:
int a=10;
int r=2;
a=a+3;
r=a*a;
可能的执行顺序是1324；
不可能是2143
单线程不会影响，那么多线程？
//线程1
context=loadContext();//语句1
inited=true;//语句2
//线程2
while(!inited){
sleep();
}
doSomethingwithconfig(context);
因为线程1中的两个语句没有数据依赖性，所以语句2有可能先于语句1执行。线程2就有可能去执行
doSomethingwithconfig(context)方法，此时context还没有初始化。
指令重排序不会影响单线程，但是多线程无法保证。
如果想要正确的执行，必须要保证-原子性-可见性-有序性。

三、java内存模型
-----
在java虚拟机中企图定义一种java内存模型，用来屏蔽各个硬件平台和操作系统的访问差异，实现让java程序在各个平台下都能达到一致的
内存访问效果。

java内存模型定义了程序中变量访问的规则，定义了程序的执行次序。
为了获得更好的执行性能，并没有限制执行引擎使用处理器的寄存器或者高速缓存，以此提升执行速度，也没有限制编译器对指令进行重排序。
java内存模型，也会有缓存一致性问题还有指令重排序问题。

java内存模型规定所有变量都存在于主内存当中（物理内存），每个线程都有自己的工作内存（cache）。线程对变量的所有操作都必须在工作内存中进行。每个线程不能访问其他线程的工作内存。

java内存模型具备happens-before原则，两个操作如果无法通过happens-before原则推导，那么就可以随意进行重排序。

happens-before：
1.程序次序原则:一个线程内，按照代码顺序，书写在前面的操作先于后面操作进行；
2.锁定原则：一个unlock操作先行发生于后面对同一个锁的lock操作
3.volatile变量原则：对一个变量的写操作先行发生于读操作
4.传递规则：如果操作A先于操作B，B先于操作C，则A先于操作C。
5.线程启动规则：thread对象的start()方法先行发生于此线程的每一个动作；
6.线程中断规则：对线程interrupt()方法的调用优先于被中断线程的代码检测到中断事件的发生
7.线程终结规则：线程所有的操作都先于线程的终止检测，可以通过Thread.join()方法结束，Thread.isAlive()方法检测
8.对象终结规则：对象的初始化完成先行发生于它的finalize()方法的开始

四、volatile关键字
-----
1.volatile保证可见性
一个共享变量（静态成员变量，成员变量）被volatile修饰后
1）保证了不同线程对这个变量进行操作时的可见性。一个操作对这个变量的值进行修改，新值其他线程是可见的
2）禁止进行指令重排。

//线程1
boolean stop=false;
while(!stop){
doSomething();
}
//线程2
stop=true;
用来在线程2中断线程1，但是有小几率无法执行，造成死循环。

小概率线程2对于stop的值进行更改后，没有向主存上传就去进行其他操作了。

1、用volatile之后，关键字会强制保证修改的值立即写入主存

2、使用volatile关键泽的话。线程2对变量进行修改会使得线程1的工作内存缓存行无效

3、线程再进行变量的操作的时候，就需要去主存请求新值了。

2.volatile不能保证原子性

public class Test {
    public volatile int inc = 0;
 
    public void increase() {
        inc++;
    }
 
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i<10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }
 
        while(Thread.activeCount()>1)  //保证前面的线程都执行完，线程数大于1，当前线程停止，进行Systemout
            Thread.yield();
        System.out.println(test.inc);
    }
}

这段代码执行结果并不是10000，都比10000小，由于自加操作没有原子性
它需要三步：取值，加一，写入内存。三步可能会分开执行，
可能某个时刻inc=10，线程1进行取值没有加一就被阻塞了；
之后线程二取值对变量自增但是还是10，因为线程1没有进行修改，所以线程2的缓存行是有效的。
最后的结果就是线程1和线程2都输入了11到主存中。

volatile无法保证对变量的任何操作都是原子性的。可以通过synchronize 和lock 加锁保证。

java1.5的java.util.concurrent.atomic包下提供了原子操作类。对自增等进行了封装

3.volatile保证有序性
volatile禁止指令重排序
1）当程序执行到volatile的时候，其前面的操作肯定都已经执行完毕，而且结果对后面的程序可见；
其后的操作还没有执行
2）指令优化时，不能将，对volatile变量的读操作或者写操作放在后面执行，也不能将后面的操作放在volatile
变量操作的前运行。即volatile位置保证不动

五、volatile的实现原理

1.可见性
处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存中的数据读取到工作内存，然后操作。
但是不确定什么时候更新写入内存。

如果声明了volatile，JVM会发送一条lock前缀指令，向处理器。将这个变量所在的缓存行数据写入到
系统内存。进一步保证线程对声明了volatile变量进行更改，则立即写入到主存中。

这时候其他处理器的缓存还是旧的，所以在多处理器的环境下，每个处理器会嗅探总线上传播的数据
来检查自己的缓存是否过期，当处理器发现自己的缓存行对应的内存地址被修改了，就会把当前缓存行无效，
当处理器需要对变量进行操作时，就要强行去主存中读取数据，到处理器缓存里。

2.有序性
Lock前缀相当于一个内存屏障，确保不会指令重排把后面的指令排到前面，也不会把前面的指令排到内存屏障后面。

六、volatile应用场景

synchronize是防止多线程同时执行一段代码，会很影响程序执行效率，volatile则在某些条件下
优于synchronize，但是volatile无法保证原子性，不能替代synchronize。
使用volatile需要具备两个条件：
1）对变量的写操作不依赖当前值
2）该变量不包含在其他变量的不变式中

1状态标记量
volatile boolean flags=false；
//线程1
while（!flags）{
doSomething();
}
//线程2
public void setFlags(){
flags=true;
}

2单例模式中的double check
class Singleton{
private volatile static Singleton instance=null;

private Singleton(){}

public static Singleton getInstance(){
if(instance==null){
synchronized(Singleton.class){
if(instance==null)
instance=new Singleton();
}
}

}
}

instance=new Singleton()这句并非是一个原子性操作，事实上在JVM中这句话大概做了下面3件事
1.给instance分配内存空间
2.调用Singleton的构造函数初始化成员变量
3.instance指向被分配的内存。
但是有可能执行顺序是132，导致2还没被执行，就被另一个线程抢占，这样就会导致instance已经指向了
分配的内存空间，但是Singleton还没有初始化。